Assemblers are programs that convert assembler code into machine language, i.e. binary code. They work directly with the respective processor architecture of the system in question and are considered efficient and resource-saving. Assemblers translate code directly into binary code, which can be created manually or by machine. Some compilers first convert program code from higher programming languages into assembler code and then use an assembler to generate the final machine code.
Assembler programs can use the entire instruction set of a processor, as each assembler instruction has a corresponding machine-level instruction. In contrast, higher programming languages are limited to a selection of these instructions and therefore sometimes offer the option of integrating assembly code into the source code if required.
Each processor has its own architecture and its own instruction set, which means that each processor also requires its own assembler in order to process the instructions accordingly. Code for a specific processor can only be understood and translated in the specific assembly language. The assembly language uses mnemonic abbreviations for the internal instructions of the processor to enable logical and arithmetic operations, register accesses and control of the program flow. Assembly language programs are therefore highly platform-dependent and programs may have to be completely redeveloped in order to be transferred to another architecture or platform. One example of this is games that are developed for both desktop PCs with Intel processors and Playstation 5 with AMD processors.
Due to its proximity to the processor architecture, assembly code offers the advantage of being able to be quickly converted into binary code, i.e. machine code. 
Nowadays, pure assembly language programming is rarely used, as both system memory in various forms and basic computing power are available at low cost and the effort is mainly made to optimize time-critical systems or for educational purposes. Assembly language often seems limited and cumbersome compared to high-level languages, as complex operations are not part of the instruction set and longer programs are required. They are also difficult to manage, as the minimalist code is difficult to understand and requires very precise documentation in the source code.

(https://www.dev-insider.de/was-ist-ein-assembler-a-756636/)